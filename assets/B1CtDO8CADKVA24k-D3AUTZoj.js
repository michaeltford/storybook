const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./CvPNnw2G6m6Cf-Iw-KeeDq91f.js","./preload-helper-D9Z9MdNV.js"])))=>i.map(i=>d[i]);
import{_ as Y}from"./preload-helper-D9Z9MdNV.js";import{M as v}from"./index-ZiyYtj3X.js";import{X as oe}from"./index-DvhsF04y.js";import"./index-J-Hv9Xln.js";import"./iframe-CBk8unIv.js";import"./index-CMiH3ff9.js";import"./index--CXhSu_I.js";import"./client-vjV3QKWK.js";/**
 * @license @sheetxl/scripting - Scripting - Scripting engine for Macros and formulas; includes TypeScript and EsBuild. - v0.6.6
 *
 * (C) 2025-present SheetXL Inc. & Michael T. Ford
 * License: The license can be found at https://www.sheetxl.com/license.
 */let L=null,O=null;const le={compilerOptions:{target:"esnext"}};async function se(y,w,S="/script.js",b="__SHEETXL"){try{const $=await async function(){if(L)return L;if(O){if(await O,!L)throw new Error("ESBuild initialization promise resolved, but instance is not available.");return L}let p,T;O=new Promise((a,m)=>{p=a,T=m});try{const{initialize:a}=await Y(async()=>{const{initialize:m}=await import("./B-prKR2s4Pk3zhWv-B1Nl-QJG.js");return{initialize:m}},[],import.meta.url);return L=await a(),p(),L}catch(a){throw console.error("Failed to import or initialize esbuild:",a),O=null,T(a),a}}(),A="@sheetxl/primitives",n=`
      export const FormulaContext = globalThis.${b}?.FormulaContext;
      export const ScalarType = globalThis.${b}?.ScalarType;
      export const Observable = globalThis.${b}?.Observable;
      export const IRange = globalThis.${b}?.IRange;
      export const FormulaError = globalThis.${b}?.FormulaError;
      // Add more exports as needed
    `,F={name:"sheetxl-esbuild-in-memory",setup(p){const T="sheetxl-"+new Date().getTime();p.onResolve({filter:new RegExp(`^(${S.replace("/","\\/")}|${A})$`)},a=>({path:a.path,namespace:T})),p.onResolve({filter:/.*/},a=>{if(a.namespace!==T)return console.warn(`esbuild: Treating import "${a.path}" as external.`),{path:a.path,external:!0}}),p.onLoad({filter:/.*/,namespace:T},a=>{let m;if(a.path===S)m=w;else{if(a.path!==A)return{errors:[{text:`Cannot load unknown path in ${T}: ${a.path}`}]};m=n}return{contents:m,loader:"ts"}})}},g=await $.build({entryPoints:[S],bundle:!0,write:!1,format:"esm",plugins:[F],sourcemap:"inline",tsconfigRaw:le,minify:!0,platform:"neutral"});if(g.outputFiles&&g.outputFiles.length>0)return g.outputFiles[0].text;throw g.errors&&g.errors.length>0?new Error(`esbuild bundling failed: ${g.errors.map(p=>p.text).join(`
`)}`):new Error("esbuild did not produce an output file.")}catch($){throw console.error("esbuild bundling process failed:",$),$}}const ce=async()=>`
  interface FirstTest {
    isTrue?: boolean;
  }
`,Z=new Map([["IReferenceRange","r"],["IRange","l"]]),ee=new Map([["IWorkbook","workbook"],["ISheet","sheet"],["ICellRanges","ranges"],["ICellRange","range"],["IFormulaContext","context"]]),X=(y,w)=>{Array.from(w.keys()).forEach(S=>{const b=w.get(S);w.set(`${y}.${S}`,b)})},ue=new Map([["Scalar","*"],["FormulaError.Known",v.Error],["Date","Date"],["JSON","JSON"]]),de=new Map([]),q="SheetXL";X(q,Z),X(q,ee),X(q,de);const pe=new Map([["Promise",()=>({async:!0})],["Observable",()=>({stream:!0})]]);let j=null;async function me(){if(j)return j;try{return await(await Y(async()=>{const{initialize:y}=await import("./CvPNnw2G6m6Cf-Iw-KeeDq91f.js");return{initialize:y}},__vite__mapDeps([0,1]),import.meta.url)).initialize()}catch(y){throw j=null,y}finally{j=null}}async function Se(y){const w=y?.source??null;if(!w)return null;const S=(y.disableBundle||y.declarationsOnly)??!1,b=[ce(),me()],$=await Promise.all(b),A=$[0],n=$[1];let F="",g=null;const p=[],T={allowJs:!0,declaration:!1,sourceMap:!1,inlineSourceMap:!1,inlineSources:!1,isolatedModules:!0,preserveConstEnums:!1,module:99,noResolve:!0,emitDeclarationOnly:!1,target:n.ScriptTarget.ES2020},a="script",m=`${a}.ts`,H="lib.d.ts",U="global.d.ts",R={[m]:w,[H]:`
/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
`,[U]:A},te={getSourceFile:(e,t,d,f)=>n.createSourceFile(e,R[e],n.ScriptTarget.Latest,!0),fileExists:e=>R[e]!==void 0,readFile:e=>R[e],writeFile:(e,t)=>{R[e]=t},getCurrentDirectory:()=>"./",getCanonicalFileName:e=>e,useCaseSensitiveFileNames:()=>!0,getDefaultLibFileName:e=>H,getNewLine:()=>`
`},V=n.createProgram([m,U],T,te),P=V.getTypeChecker(),ne=V.getSourceFile(m),W=V.emit();W.diagnostics.length>0&&console.warn(W.diagnostics),F=R[`${a}.js`];const I=(e,t,d,f)=>{if(e){if(e.kind===n.SyntaxKind.NumberKeyword)t.scalar=v.Number;else if(e.kind===n.SyntaxKind.StringKeyword)t.scalar=v.String;else if(e.kind===n.SyntaxKind.BooleanKeyword)t.scalar=v.Boolean;else if(e.kind===n.SyntaxKind.UndefinedKeyword||e.kind===n.SyntaxKind.NullKeyword||e.kind===n.SyntaxKind.VoidKeyword){if(f)return void k(e,new Error(`'undefined' is not a valid type for input: '${e?.parent?.name?.escapedText}'.`));t.scalar=v.Null}else if(e.kind===n.SyntaxKind.BigIntKeyword)t.scalar=v.Number;else if(e.kind===n.SyntaxKind.AnyKeyword)t.scalar=v.Null;else if(e.kind===n.SyntaxKind.ArrayType){const o=e.elementType;if(!o)return void k(e,new Error(`'Array' must be typed: '${e?.parent?.name?.escapedText}'.`));t.arrayDepth=(t.arrayDepth??0)+1,I(o,t,d,f)}else if(e.kind!==n.SyntaxKind.TupleType&&e.kind===n.SyntaxKind.TypeReference){const o=e.typeName?.getText?.()??null,M=Z.get(o);let E=!1;M&&(t.range=M,E=!0);const D=ue.get(o);if(D&&(t.scalar=D),D!==void 0&&(E=!0),f){const r=ee.get(o);if(r)return r}else{const r=pe.get(o);if(r){const l={...t,...r()};let h=0;if(l.async&&h++,l.stream&&h++,h>1)return void k(e,new Error(`'${o}' cannot have multiple modifiers: '${e?.parent?.name?.escapedText}'.`));t=l,E=!0}}if(!E)return void k("node",new Error(`'${o}' is not a valid type: '${e?.parent?.name?.escapedText}'.`));const u=e.typeArguments;if(u){if(u.length!==1)return void k(e,new Error(`'${o}' must be typed with exactly 1 type: '${e?.parent?.name?.escapedText}'.`));I(u[0],t,d,f)}}}else k(e,new Error(`Type is not defined for '${t?.name??"return"}'.`))},z=[],k=(e,t)=>{z.push(t)};if(n.forEachChild(ne,e=>{if((t=>(n.getCombinedModifierFlags(t)&n.ModifierFlags.Export)!==0)(e)&&n.isFunctionDeclaration(e)){const t={},d={parameters:{}},f=e?.name?.getText();try{t.name=f;const o=P.getSymbolAtLocation(e.name).getDocumentationComment(P);if(o&&o.length>0&&o[0].text){let u=o[0].text;u=u.replace(/[\r\n]+/g,"\\n").trim(),d.summary=u}const M={};I(e.type,M,t,!1),t.returnType=M;const E={};(u=>(n.getCombinedModifierFlags(u)&n.ModifierFlags.Default)!==0)(e)&&(E.default=!0,g=f),Object.keys(E).length>0&&(t.behavior=E),t.parameters=[];const D=new Map;for(let u=0;u<e.parameters.length;u++){const r=e.parameters[u],l={};l.name=r.name?.getText();const h=I(r.type,l,t,!0);if(h){if(t.parameters.length!==0){const C=e?.parent,c=C?.name?.getText();return void k(e,new Error(`'${t.name}' contexts must be the first parameter: '${c}'.`))}t.context=h;continue}let x;if((r.initializer!==void 0&&r.initializer!==null||r.questionToken!==void 0&&r.questionToken!==null)&&(l.optional=!0,r.initializer))try{x=r.initializer.kind===n.SyntaxKind.StringLiteral?r.initializer.text:r.initializer.kind===n.SyntaxKind.NumericLiteral?parseFloat(r.initializer.text):r.initializer.kind===n.SyntaxKind.TrueKeyword||r.initializer.kind===n.SyntaxKind.FalseKeyword?r.initializer.kind===n.SyntaxKind.TrueKeyword:r.initializer.kind===n.SyntaxKind.NullKeyword?null:r.initializer.kind===n.SyntaxKind.ObjectLiteralExpression||r.initializer.kind===n.SyntaxKind.ArrayLiteralExpression?r.initializer.getText():r.initializer.getText?.()}catch(C){console.warn(`Couldn't extract default value for parameter '${l.name}'`,C)}r.dotDotDotToken&&(l.rest=!0),t.parameters.push(l);const s={description:""};d.parameters[l.name]=s;const i=P.getSymbolAtLocation(r.name).getDocumentationComment(P);i&&i.length>0&&i[0].text&&(s.description=i[0].text),x!==void 0&&(s.defaultValue=x),D.set(l.name,l)}if(e.jsDoc&&e.jsDoc.length>0){const u=e.jsDoc;for(let r=0;r<u.length;r++){const l=u[r]?.tags;if(l)for(let h=0;h<l.length;h++){const x=l[h];let s=x?.tagName?.text;if(!s)continue;s=s.toLowerCase();let i=x.comment;const C=s==="hidden";if((typeof i=="string"||C)&&(typeof i=="string"&&(i=i.replace(/[\r\n]+/g,"\\n").trim()),C||!i||(i=i.split(/\\n/)[0],i&&i.length!==0))){if(i&&typeof i=="string"){const c=/\{@link(code|plain)?\s+([^}|]+)(?:\s*\|\s*([^}]+))?\}/g;let K,N=i,_=[];for(;(K=c.exec(i))!==null;){const[B,J,ie,Q]=K,ae=[ie.trim()];Q&&ae.push(Q.trim())}i=N,_.length>0&&s==="see"&&(d.links||(d.links=[]),d.links.push(..._))}if(s==="name"){const c=i;c!==f&&(d.name=c)}else if(s!=="description"){if(s==="summary"){const c=i;c&&(d.summary=c)}else if(s==="param"){const c=x.name?.text,K=D.get(c);if(!K){z.push(new Error(`Parameter '${c}' not found in function '${f}'.`));continue}if(x.typeExpression&&x.typeExpression.type)try{const N=x.typeExpression.type;if(N.kind===n.SyntaxKind.UnionType){const _=[];K.enums=_,N.types.forEach(B=>{if(B.kind===n.SyntaxKind.LiteralType){const J=B.literal.text;J&&_.push(J)}})}}catch(N){console.warn("Error parsing JSDoc type expression:",N)}}else if(s==="returns"||s==="return")t.returnType.description=i;else if(s==="category")d.category=i;else if(s==="hidden"){let c=!0;const K=i?.toLowerCase();K==="false"?c=!1:K!=="true"&&(c=i),c!==!1&&(d.hidden=c??!0)}}}}}}Object.keys(t.returnType).length===0&&delete t.returnType,p.push([t,d])}catch(o){k(e,new Error(`'${f}': ${o.message}`))}}}),z.length>0)throw console.warn(z),new Error("There were compilation errors.",{cause:z});if(p.length===0)throw new Error("No exported functions.");const re=`${oe.uuidV4()}-script`;try{S||z.length!==0||(F=await se(0,F,a))}catch{console.warn("Error bundling script")}const G={functions:p,commitId:re,source:w,name:"Script",language:"typescript",compiled:F};return g&&(G.autoRun=g),G}export{Se as compileModule};
